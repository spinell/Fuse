#include "TextureGenerator.h"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <ctime>

namespace TextureGenerator {


ImageData generateFlatImage(unsigned width, unsigned height, Color color) {
    assert(width > 0);
    assert(height > 0);
    ImageData ImageData(width, height);
    ImageData.pixels.assign(width * height, color);
    return ImageData;
}

//
// Generated by IA + modification.
//
ImageData generateBrickTexture1(unsigned textureWidth, unsigned textureHeight) {
    assert(textureWidth > 0);
    assert(textureHeight > 0);
    ImageData   textureData(textureWidth, textureHeight);
    const Color kMortarColor = {100, 100, 100, 255}; // Mortar color (dark grey)
    const Color kBrickColor  = {150, 75, 50, 255};   // Brick color (reddish-brown)
    const float brickWidth   = 24.0f;
    const float brickHeight  = 8.0f;
    const float mortarSize   = 0.02f;

    auto frac = [](float value) -> float { return value - std::floor(value); };

    for (unsigned y = 0; y < textureHeight; ++y) {
        for (unsigned x = 0; x < textureWidth; ++x) {
            // Calculate normalized UV coordinates
            const float u = (float)x / (float)textureWidth;
            const float v = (float)y / (float)textureHeight;

            // Tile the UVs
            float tiledU = u * ((float)textureWidth / (float)brickWidth);
            float tiledV = v * ((float)textureHeight / (float)brickHeight);

            // Stagger alternate rows
            if (std::floor(tiledV) * 0.5f == std::floor(std::floor(tiledV) * 0.5f)) {
                tiledU += 0.5f;
            }

            // Check for mortar region
            if (frac(tiledU) > mortarSize && frac(tiledV) > mortarSize) {
                textureData(y, x) = kBrickColor;
            } else {
                textureData(y, x) = kMortarColor;
            }
        }
    }
    return textureData;
}


//
// Generated by IA + modification.
//
ImageData generateBrickTexture2(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);
    const unsigned char BRICK_RED[3]   = {188, 66, 52};
    const unsigned char MORTAR_GREY[3] = {120, 120, 120};
    const unsigned int  brickWidth     = 100; // in pixels
    const unsigned int  brickHeight    = 50;  // in pixels
    const unsigned int  mortarSize     = 5;   // in pixels

    ImageData textureData(width, height);

    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            // Calculate brick coordinates
            const unsigned row   = y / (brickHeight + mortarSize);
            const unsigned y_pos = y % (brickHeight + mortarSize);

            // Apply horizontal offset for every other row (running bond)
            const unsigned x_offset = (row % 2) * (brickWidth / 2);
            const unsigned x_pos    = (x + x_offset) % (brickWidth + mortarSize);

            // Determine if the current pixel is part of a brick or mortar
            bool isMortar = (y_pos < mortarSize) || (x_pos < mortarSize);

            // Add some variation/noise to the bricks
            const float noise     = static_cast<float>(std::rand()) / static_cast<float>(RAND_MAX) * 0.1f;
            const int   variation = static_cast<int>(noise * 50);

            unsigned char r, g, b;
            if (isMortar) {
                r = MORTAR_GREY[0];
                g = MORTAR_GREY[1];
                b = MORTAR_GREY[2];
            } else {
                r = static_cast<unsigned char>(std::clamp(BRICK_RED[0] + variation, 0, 255));
                g = static_cast<unsigned char>(std::clamp(BRICK_RED[1] + variation, 0, 255));
                b = static_cast<unsigned char>(std::clamp(BRICK_RED[2] + variation, 0, 255));
            }

            // Set the pixel color
            textureData(y, x) = {r, g, b};
        }
    }

    return textureData;
}

//
// Generated by IA + modification.
//
ImageData generateBrickTexture3(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);
    ImageData image(width, height);

    // Define brick and mortar properties
    const unsigned brick_width      = 80;
    const unsigned brick_height     = 40;
    const unsigned mortar_thickness = 4;
    const Color    kBrickColor      = {200, 50, 50};   // Brick color (dark red)
    const Color    kMotorColor      = {100, 100, 100}; // Mortar color
    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            // Determine which row of bricks we are in
            unsigned row = y / (brick_height + mortar_thickness);
            // Determine which column of bricks we are in, with offset for alternating rows (stretcher bond)
            // Offset every second row by half a brick width
            //unsigned col = (x - (row % 2) * (brick_width / 2)) / (brick_width + mortar_thickness);

            // Check if the current pixel is in the mortar area
            bool is_mortar_y = (y % (brick_height + mortar_thickness)) >= brick_height;
            bool is_mortar_x = ((x - (row % 2) * (brick_width / 2)) %
                                (brick_width + mortar_thickness)) >= brick_width;

            if (is_mortar_y || is_mortar_x) {
                image(y, x) = kMotorColor;
            } else {
                image(y, x) = kBrickColor;
            }
        }
    }

    return image;
}

//
// Generated by IA + modification.
//
ImageData generateBrickTexture4(unsigned width, unsigned height, unsigned brickWidth,
                                unsigned brickHeight, unsigned mortarThickness) {
    assert(width > 0);
    assert(height > 0);

    const Color kMotorColor = {100, 100, 100};
    const Color kBrickColor = {180, 60, 40};
    ImageData   image_data(width, height);

    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            // Check if the current pixel is in the mortar area
            bool isMortar = (y % (brickHeight + mortarThickness) >= brickHeight) ||
                            (x % (brickWidth + mortarThickness) >= brickWidth);

            if (isMortar) {
                image_data(y, x) = kMotorColor;
            } else {
                image_data(y, x) = kBrickColor;
                // Add minor color variations here for realism
            }
        }
    }
    return image_data;
}

//
// Generated by IA + modification.
//
ImageData generateBrickTexture5(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);

    ImageData textureData(width, height);

    // Function to get the color for a given UV coordinate (0.0 to 1.0)
    auto getProceduralBrickColor = [](float u, float v) -> Color {
        // Define brick parameters (normalized to 1.0 for UV space calculation)
        const float BRICK_WIDTH  = 0.1f;          // original value = 0.5f;
        const float BRICK_HEIGHT = 0.05f;         // original value = 0.25f;
        const float MORTAR_SIZE  = 0.002f;        // original value = 0.02f;
        const Color kMortarColor = {70, 70, 70};  // Mortar color (dark gray)
        const Color kBrickColor  = {180, 80, 50}; // Brick color (reddish-brown)

        // Tile the UV coordinates across the texture
        float       tiled_u = std::fmod(u, 1.0f);
        const float tiled_v = std::fmod(v, 1.0f);

        // Get the current row number
        const int row = static_cast<int>(v / BRICK_HEIGHT);

        // Offset every other row
        if (row % 2 == 1) {
            tiled_u += BRICK_WIDTH / 2.0f;
        }

        // Determine if the current pixel is part of a brick or mortar
        const bool is_mortar_u = std::fmod(tiled_u, BRICK_WIDTH) < MORTAR_SIZE ||
                                 std::fmod(tiled_u, BRICK_WIDTH) > (BRICK_WIDTH - MORTAR_SIZE);
        const bool is_mortar_v = std::fmod(tiled_v, BRICK_HEIGHT) < MORTAR_SIZE ||
                                 std::fmod(tiled_v, BRICK_HEIGHT) > (BRICK_HEIGHT - MORTAR_SIZE);

        if (is_mortar_u || is_mortar_v) {
            return kMortarColor;
        } else {
            // Simple brick color, add noise for variation in a real application
            return kBrickColor;
        }
    };

    for (unsigned row = 0; row < height; ++row) {
        for (unsigned col = 0; col < width; ++col) {
            // Calculate UV coordinates for the current pixel
            const float u = static_cast<float>(col) / static_cast<float>(width - 1);
            const float v = static_cast<float>(row) / static_cast<float>(height - 1);

            // Get the color for the UV coordinate
            Color pixelColor = getProceduralBrickColor(u, v);

            // Store the color in the texture data array
            textureData(row, col) = pixelColor;
        }
    }

    return textureData;
}

//
// Generated by IA + modification.
//
ImageData generateBrickTexture6(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);

    const Color kMortarColor = {80, 80, 80};  // Mortar color (dark grey)
    const Color kBrickColor  = {180, 60, 40}; // Brick color (reddish-brown)
    // Brick/Mortar dimensions (normalized to 0.0 to 1.0)
    const float BRICK_WIDTH      = 0.3f;
    const float BRICK_HEIGHT     = 0.15f;
    const float MORTAR_THICKNESS = 0.01f;
    ImageData   textureData(width, height);

    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            // Normalize coordinates to a 0.0 to 1.0 range
            float u = (float)x / (float)width;
            float v = (float)y / (float)height;

            // Apply tiling
            u = std::fmod(u, 1.0f);
            v = std::fmod(v, 1.0f);

            // Offset every other row for a standard "stretcher bond" pattern
            if (std::floor(v / BRICK_HEIGHT) * 0.5f == std::floor(std::floor(v / BRICK_HEIGHT) * 0.5f)) {
                // Even rows: no offset
            } else {
                // Odd rows: half brick width offset
                u += BRICK_WIDTH * 0.5f;
            }

            // Check if current pixel is within a brick or mortar
            bool isMortar = false;
            if (std::fmod(u, BRICK_WIDTH) < MORTAR_THICKNESS ||
                std::fmod(v, BRICK_HEIGHT) < MORTAR_THICKNESS) {
                isMortar = true;
            }

            textureData(y, x) = isMortar ? kMortarColor : kBrickColor;
        }
    }
    return textureData;
}


//
// Generated by IA + modification.
//
ImageData generateGrass(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);

    ImageData pixels(width, height);
    std::srand((unsigned)std::time(nullptr));

    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {

            // Base green color
            unsigned char r = 34;
            unsigned char g = 139;
            unsigned char b = 34;

            // Add some random variation for natural look
            r += static_cast<unsigned char>((std::rand() % 20) - 10);
            g += static_cast<unsigned char>((std::rand() % 30) - 15);
            b += static_cast<unsigned char>((std::rand() % 20) - 10);

            // Optional: a simple "blade" pattern near the bottom
            if (y > height / 2 && std::rand() % 10 < 1) {
                g += 40; // brighter speckle
            }

            pixels(y, x) = {r, g, b};
        }
    }
    return pixels;
}


ImageData generateGrass2(unsigned width, unsigned height) {
    assert(width > 0);
    assert(height > 0);

    ImageData pixels(width, height);
    std::srand((unsigned)std::time(nullptr));
    // PerlinNoise noiseGenerator; // Initialize your noise generator

    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {

            // Use noise to get a value between 0.0 and 1.0
            // float noiseVal = noiseGenerator.getNoise(x * scale, y * scale);
            float noiseVal = (float)std::rand() / (float)RAND_MAX; // Placeholder for actual noise function

            // Map noise value to shades of green
            unsigned char r = static_cast<unsigned char>(30 + noiseVal * 50);
            unsigned char g = static_cast<unsigned char>(100 + noiseVal * 155);
            unsigned char b = static_cast<unsigned char>(30 + noiseVal * 50);

            pixels(y, x) = {r, g, b};
        }
    }
    return pixels;
}


ImageData generateCheckerboard(unsigned int width, unsigned int height, Color color1, Color color2,
                               unsigned int squareSize) {
    assert(width > 0);
    assert(height > 0);
    assert(squareSize > 0);

    ImageData pixels(width, height);
    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            // Determine the color based on the square's coordinates
            // The logic ((x / squareSize) + (y / squareSize)) % 2 results in an alternating 0 or 1
            if (((x / squareSize) + (y / squareSize)) % 2 == 0) {
                pixels(y, x) = color1;
            } else {
                pixels(y, x) = color2;
            }
        }
    }
    return pixels;
}

ImageData generateXor(unsigned int width, unsigned int height) {
    assert(width > 0);
    assert(height > 0);

    ImageData data(width, height);
    for (unsigned y = 0; y < height; ++y) {
        for (unsigned x = 0; x < width; ++x) {
            const unsigned char color_component = (unsigned char)(x ^ y);

            data(y, x) = {color_component, color_component, color_component};
        }
    }
    return data;
}


} // namespace TextureGenerator
